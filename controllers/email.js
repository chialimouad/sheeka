const Email = require('../models/emails');
const ClientEmail = require('../models/clientemail');
const Response = require('../models/emailres');
const AdminCredential = require('../models/admin'); // Consider if this model is still needed for credentials
const nodemailer = require('nodemailer');
const dotenv = require('dotenv');
// const bcrypt = require('bcryptjs'); // Uncomment if you decide to hash stored passwords (not recommended for direct Nodemailer use)

dotenv.config(); // Load environment variables

// --- IMPORTANT SECURITY NOTE ON EMAIL CREDENTIALS ---
// Storing email passwords directly in the database or code is highly insecure.
// For production, it is strongly recommended to:
// 1. Use environment variables (process.env.ADMIN_EMAIL, process.env.ADMIN_EMAIL_APP_PASSWORD)
//    for the sending email address and an "App Password" (generated by Gmail/Outlook for 2FA accounts).
// 2. Implement OAuth2 for Nodemailer, which avoids storing passwords.
// This refactored code will primarily rely on environment variables for the sending email.
// The `setAdminCredentials` route is modified to reflect this best practice.

// Global transporter instance, initialized once with environment variables
let transporter;

/**
 * @desc Initializes or updates the Nodemailer transporter using credentials from environment variables.
 * This function should ideally be called once on application startup or when credentials are known.
 * @returns {Object|null} The Nodemailer transporter instance, or null if credentials are not set.
 */
const initializeTransporter = () => {
    const adminEmail = process.env.ADMIN_EMAIL;
    const adminAppPassword = process.env.ADMIN_EMAIL_APP_PASSWORD; // Use an App Password, NOT your main email password

    if (!adminEmail || !adminAppPassword) {
        console.error('ERROR: ADMIN_EMAIL or ADMIN_EMAIL_APP_PASSWORD not set in environment variables. Email sending will fail.');
        transporter = null; // Ensure transporter is null if credentials are missing
        return null;
    }

    // Only create a new transporter if it doesn't exist or credentials have changed (though env vars are static)
    if (!transporter) {
        transporter = nodemailer.createTransport({
            service: 'gmail', // Configure for your email service (e.g., 'Outlook', 'SMTP', etc.)
            auth: {
                user: adminEmail,
                pass: adminAppPassword
            },
            // Add security options for production
            secure: true, // Use SSL/TLS
            tls: {
                rejectUnauthorized: false // Set to true in production if you have a valid SSL certificate
            }
        });
        console.log('Nodemailer transporter initialized successfully.');
    }
    return transporter;
};

// Initialize transporter on module load
initializeTransporter();

/**
 * @desc Set/Update admin email credentials.
 * WARNING: This route is for demonstration/testing ONLY.
 * In a production environment, admin email and app password should be loaded from environment variables
 * and NOT stored in the database or set via an API endpoint like this.
 * If dynamic setting is absolutely required, implement strong encryption for the password and robust authentication.
 * @route POST /api/admin-credentials
 * @access Private (should be protected with proper authentication/authorization in production)
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 */
exports.setAdminCredentials = async (req, res) => {
    // This route is primarily for demonstrating how credentials *could* be handled,
    // but the actual sending should use environment variables for security.
    const { email, password } = req.body; // These are for testing/demonstration only

    if (!email || !password) {
        return res.status(400).json({ message: 'Email and password are required to set admin credentials (for testing purposes).' });
    }

    try {
        // This part of the code is kept for backward compatibility with the `AdminCredential` model,
        // but it's highly recommended to use environment variables for the actual `transporter` setup.
        let adminCred = await AdminCredential.findOne();
        if (adminCred) {
            adminCred.email = email;
            // adminCred.password = await bcrypt.hash(password, 10); // If you MUST store, hash it!
            adminCred.password = password; // WARNING: Storing passwords directly is INSECURE.
            await adminCred.save();
            console.log('Admin credentials updated in DB (for reference, not direct sending).');
        } else {
            // adminCred = new AdminCredential({ email, password: await bcrypt.hash(password, 10) }); // If you MUST store, hash it!
            adminCred = new AdminCredential({ email, password }); // WARNING: Storing passwords directly is INSECURE.
            await adminCred.save();
            console.log('Admin credentials set in DB (for reference, not direct sending).');
        }

        // Re-initialize transporter with the *new* credentials for immediate testing/use,
        // but emphasize that production should use environment variables.
        // For a single admin email, it's better to just restart the app after updating .env
        // initializeTransporter(); // This would use environment variables, not the passed ones.
        // For testing the *passed* credentials immediately:
        try {
            const testTransporter = nodemailer.createTransport({
                service: 'gmail',
                auth: { user: email, pass: password }
            });
            await testTransporter.verify(); // Try to verify the credentials
            console.log('Provided credentials are valid and transporter can be created.');
            res.status(200).json({ message: 'Admin email credentials processed. WARNING: Direct storage is insecure. For production, use environment variables.', credentials: { email: adminCred.email } });
        } catch (transporterError) {
            console.error('ERROR: Provided credentials failed Nodemailer verification:', transporterError.message);
            res.status(400).json({ message: 'Provided email credentials are invalid or failed to connect. Check email and app password.', error: transporterError.message });
        }

    } catch (error) {
        console.error('Error setting admin credentials:', error.message);
        res.status(500).json({ message: 'Server error while setting admin credentials. Please try again.' });
    }
};

/**
 * @desc Send an email from a client and save it to the database.
 * Also adds the client's email to the ClientEmail collection if it's new.
 * @route POST /api/emails
 * @access Public
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 */
exports.sendEmail = async (req, res) => {
    const { senderEmail, senderName, message } = req.body;

    // Basic validation
    if (!senderEmail || !senderName || !message) {
        return res.status(400).json({ message: 'Please provide senderEmail, senderName, and message.' });
    }

    // Basic email format validation
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(senderEmail)) {
        return res.status(400).json({ message: 'Invalid sender email format.' });
    }

    try {
        // 1. Save the email message to the 'emails' collection
        const newEmail = new Email({
            senderEmail,
            senderName,
            message
        });
        await newEmail.save();

        // 2. Add the sender's email to the 'clientemails' collection if it doesn't already exist
        // Use findOneAndUpdate with upsert for atomic operation
        await ClientEmail.findOneAndUpdate(
            { emailAddress: senderEmail },
            { $setOnInsert: { emailAddress: senderEmail } }, // Only set if inserting new
            { upsert: true, new: true, setDefaultsOnInsert: true }
        );
        console.log(`Client email processed: ${senderEmail}`);

        res.status(201).json({ message: 'Email received and saved successfully!', email: newEmail });
    } catch (error) {
        console.error('Error sending or saving client email:', error.message);
        res.status(500).json({ message: 'Server error while processing client email. Please try again.' });
    }
};

/**
 * @desc Fetch all sent emails from the 'emails' collection.
 * @route GET /api/emails
 * @access Private (consider adding authentication for production)
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 */
exports.getSentEmails = async (req, res) => {
    try {
        // Fetch all emails, sorted by creation date descending
        const emails = await Email.find().sort({ createdAt: -1 });
        res.status(200).json(emails);
    } catch (error) {
        console.error('Error fetching emails:', error.message);
        res.status(500).json({ message: 'Server error while fetching emails. Please try again.' });
    }
};

/**
 * @desc Fetch all unique client emails from the 'clientemails' collection.
 * @route GET /api/clients
 * @access Private (should be protected with proper authentication/authorization)
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 */
exports.getClientEmails = async (req, res) => {
    try {
        const clientEmails = await ClientEmail.find().sort({ createdAt: -1 });
        res.status(200).json(clientEmails);
    } catch (error) {
        console.error('Error fetching client emails:', error.message);
        res.status(500).json({ message: 'Server error while fetching client emails. Please try again.' });
    }
};

/**
 * @desc Fetch all sent responses from the 'responses' collection.
 * @route GET /api/responses
 * @access Private (should be protected with proper authentication/authorization)
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 */
exports.getResponses = async (req, res) => {
    try {
        const responses = await Response.find().sort({ sentAt: -1 });
        res.status(200).json(responses);
    } catch (error) {
        console.error('Error fetching responses:', error.message);
        res.status(500).json({ message: 'Server error while fetching responses. Please try again.' });
    }
};

/**
 * @desc Send a response email to all clients who have sent an email
 * and have not yet received a response.
 * @route POST /api/emails/send-response
 * @access Private (requires admin authentication/authorization)
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 */
exports.sendResponseToAllClients = async (req, res) => {
    const { responseSubject, responseMessage } = req.body;

    if (!responseSubject || !responseMessage) {
        return res.status(400).json({ message: 'Please provide a response subject and message.' });
    }

    // Ensure transporter is initialized (using environment variables)
    const currentTransporter = initializeTransporter();
    if (!currentTransporter) {
        return res.status(500).json({ message: 'Email sending service is not configured. Please check server logs for ADMIN_EMAIL and ADMIN_EMAIL_APP_PASSWORD.' });
    }

    try {
        // --- Performance Improvement: Efficiently find emails that haven't received a response ---
        // 1. Get IDs of all emails that have already received a response
        const respondedEmailIds = (await Response.find({}, { emailId: 1, _id: 0 }))
            .map(r => r.emailId); // Keep as ObjectId for direct comparison in Mongoose

        // 2. Find emails that have NOT been responded to, using $nin (not in) operator
        const emailsToRespond = await Email.find({
            _id: { $nin: respondedEmailIds }
        });

        if (emailsToRespond.length === 0) {
            return res.status(200).json({ message: 'No new emails found that require a response.' });
        }

        let successCount = 0;
        let failedEmails = [];

        // Use Promise.allSettled for concurrent sending and better error handling for each email
        const sendPromises = emailsToRespond.map(async (emailDoc) => {
            const mailOptions = {
                from: process.env.ADMIN_EMAIL, // Use the admin's email from environment variables
                to: emailDoc.senderEmail,      // Recipient's email (original sender)
                subject: responseSubject,
                text: `Dear ${emailDoc.senderName},\n\n${responseMessage}\n\nBest regards,\nYour Team`
            };

            try {
                await currentTransporter.sendMail(mailOptions);
                console.log(`Response sent to: ${emailDoc.senderEmail} (Original Email ID: ${emailDoc._id})`);

                // Create a new entry in the 'responses' collection for this sent response
                const newResponse = new Response({
                    emailId: emailDoc._id,
                    subject: responseSubject,
                    message: responseMessage
                });
                await newResponse.save();
                successCount++; // Increment success count only on successful send and save
                return { status: 'fulfilled', email: emailDoc.senderEmail };
            } catch (mailError) {
                console.error(`Failed to send response to ${emailDoc.senderEmail} (Original Email ID: ${emailDoc._id}):`, mailError.message);
                failedEmails.push({ email: emailDoc.senderEmail, error: mailError.message });
                return { status: 'rejected', email: emailDoc.senderEmail, error: mailError.message };
            }
        });

        await Promise.allSettled(sendPromises); // Wait for all emails to attempt sending

        res.status(200).json({
            message: `Attempted to send responses to ${emailsToRespond.length} emails.`,
            successfulSends: successCount,
            failedSends: failedEmails.length,
            failedEmails: failedEmails.map(f => f.email) // Return just emails for failed list
        });

    } catch (error) {
        console.error('Error in sendResponseToAllClients:', error.message);
        res.status(500).json({ message: 'Server error while sending responses. Please try again.' });
    }
};
